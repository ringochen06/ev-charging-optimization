{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c59e7d0c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# %%\n",
    "\"\"\"\n",
    "NYC EV Charging Station Optimization\n",
    "Notebook 02: Gap Score Calculation\n",
    "\n",
    "ç›®æ ‡: å®žçŽ°Gap Scoreå…¬å¼ï¼Œè¯†åˆ«å……ç”µéœ€æ±‚ç¼ºå£\n",
    "è¾“å…¥: NYC EVå……ç”µç«™æ•°æ® + å¤–éƒ¨æ•°æ®æº\n",
    "è¾“å‡º: å„åŒºåŸŸçš„Gap Score + ä¼˜å…ˆçº§æŽ’åº\n",
    "\"\"\"\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import folium\n",
    "from folium import plugins\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "print(\"Loading data...\")\n",
    "\n",
    "df_stations = pd.read_csv(\"NYC_EV_Fleet_Station_Network_20250709.csv\")\n",
    "print(f\"Loaded {len(df_stations)} charging stations\")\n",
    "\n",
    "df_clean = df_stations.dropna(subset=['LATITUDE', 'LONGITUDE']).copy()\n",
    "print(f\"Stations with valid coordinates: {len(df_clean)}\")\n",
    "\n",
    "print(\"\\n Calculating Gap Score components...\")\n",
    "\n",
    "def calculate_charging_density(df, area_type='borough'):\n",
    "    \"\"\"\n",
    "    Calculate charging station density by area type\n",
    "    \"\"\"\n",
    "    if area_type == 'borough':\n",
    "        # number of charging stations per borough\n",
    "        borough_counts = df.groupby('BOROUGH').size()\n",
    "        \n",
    "        # NYC borough areas in square miles\n",
    "        borough_areas = {\n",
    "            'Manhattan': 23,\n",
    "            'Brooklyn': 70, \n",
    "            'Queens': 109,\n",
    "            'Bronx': 42,\n",
    "            'Staten Island': 58\n",
    "        }\n",
    "        \n",
    "        charging_density = {}\n",
    "        for borough in borough_counts.index:\n",
    "            if borough in borough_areas:\n",
    "                density = borough_counts[borough] / borough_areas[borough]\n",
    "                charging_density[borough] = density\n",
    "        \n",
    "        return pd.Series(charging_density, name='charging_density')\n",
    "    \n",
    "    # TODO: ZIP code level density calculation\n",
    "    return None\n",
    "\n",
    "# è®¡ç®—å……ç”µå¯†åº¦\n",
    "charging_density = calculate_charging_density(df_clean)\n",
    "print(\"Charging density by borough:\")\n",
    "print(charging_density.round(2))\n",
    "\n",
    "# %%\n",
    "# 2.2 EVéœ€æ±‚ä»£ç†å˜é‡ (EV_Demand_Proxy)\n",
    "def estimate_ev_demand_proxy():\n",
    "    \"\"\"\n",
    "    ç”±äºŽç¼ºä¹ç›´æŽ¥çš„EVæ‹¥æœ‰é‡æ•°æ®ï¼Œæˆ‘ä»¬ç”¨ä»£ç†å˜é‡ä¼°ç®—\n",
    "    åŸºäºŽï¼šé«˜æ”¶å…¥ã€å¹´è½»äººå£ã€çŽ¯ä¿æ„è¯†ç­‰å› ç´ \n",
    "    \"\"\"\n",
    "    # è¿™é‡Œæˆ‘ä»¬å…ˆç”¨ä¸€ä¸ªç®€åŒ–çš„ä¼°ç®—æ–¹æ³•\n",
    "    # åœ¨å®žé™…é¡¹ç›®ä¸­ï¼Œä½ éœ€è¦èŽ·å–censusæ•°æ®æˆ–å…¶ä»–å¤–éƒ¨æ•°æ®æº\n",
    "    \n",
    "    # æ¨¡æ‹Ÿæ•°æ® - å®žé™…é¡¹ç›®ä¸­éœ€è¦æ›¿æ¢ä¸ºçœŸå®žæ•°æ®\n",
    "    borough_ev_demand = {\n",
    "        'Manhattan': 8.5,  # é«˜æ”¶å…¥ï¼ŒçŽ¯ä¿æ„è¯†å¼º\n",
    "        'Brooklyn': 6.2,   # å¹´è½»äººå£å¤š\n",
    "        'Queens': 5.8,     # å¤šæ ·åŒ–ç¤¾åŒº  \n",
    "        'Bronx': 3.4,      # ç›¸å¯¹è¾ƒä½Žæ”¶å…¥\n",
    "        'Staten Island': 4.1  # éƒŠåŒºï¼Œä½†è½¦è¾†ä¾èµ–åº¦é«˜\n",
    "    }\n",
    "    \n",
    "    return pd.Series(borough_ev_demand, name='ev_demand_proxy')\n",
    "\n",
    "ev_demand = estimate_ev_demand_proxy()\n",
    "print(\"\\nEV Demand Proxy by borough:\")\n",
    "print(ev_demand.round(2))\n",
    "\n",
    "# %%\n",
    "# 2.3 äº¤é€šå¼ºåº¦ (Traffic_Intensity)  \n",
    "def estimate_traffic_intensity():\n",
    "    \"\"\"\n",
    "    ä¼°ç®—å„åŒºåŸŸçš„äº¤é€šå¼ºåº¦\n",
    "    åŸºäºŽäººå£å¯†åº¦ã€å•†ä¸šæ´»åŠ¨ç­‰å› ç´ \n",
    "    \"\"\"\n",
    "    # åŸºäºŽNYCå¼€æ”¾æ•°æ®å’Œå¸¸è¯†çš„ä¼°ç®—\n",
    "    borough_traffic = {\n",
    "        'Manhattan': 9.2,    # æœ€é«˜äº¤é€šå¯†åº¦\n",
    "        'Brooklyn': 6.8,     # é«˜å¯†åº¦ä½å®…åŒº\n",
    "        'Queens': 6.1,       # æœºåœºã€é«˜é€Ÿå…¬è·¯\n",
    "        'Bronx': 5.3,        # ä¸­ç­‰å¯†åº¦\n",
    "        'Staten Island': 4.5  # æœ€ä½Žå¯†åº¦ï¼Œä½†è½¦è¾†ä¾èµ–\n",
    "    }\n",
    "    \n",
    "    return pd.Series(borough_traffic, name='traffic_intensity')\n",
    "\n",
    "traffic_intensity = estimate_traffic_intensity()\n",
    "print(\"\\nTraffic Intensity by borough:\")\n",
    "print(traffic_intensity.round(2))\n",
    "\n",
    "# %%\n",
    "# ===== 3. Gap Score è®¡ç®— =====\n",
    "print(\"\\nðŸŽ¯ Calculating Gap Scores...\")\n",
    "\n",
    "def calculate_gap_score(ev_demand, traffic_intensity, charging_density, \n",
    "                       w1=0.5, w2=0.3, w3=0.2):\n",
    "    \"\"\"\n",
    "    è®¡ç®—Gap Score\n",
    "    Gap_Score = w1 * EV_Demand_Proxy + w2 * Traffic_Intensity - w3 * Charging_Density\n",
    "    \n",
    "    å‚æ•°:\n",
    "    - w1: EVéœ€æ±‚æƒé‡\n",
    "    - w2: äº¤é€šå¼ºåº¦æƒé‡  \n",
    "    - w3: å……ç”µå¯†åº¦æƒé‡ (è´Ÿå·ï¼Œå¯†åº¦è¶Šé«˜gapè¶Šå°)\n",
    "    \"\"\"\n",
    "    # æ ‡å‡†åŒ–å„ç»„ä»¶ (0-10 scale)\n",
    "    scaler = StandardScaler()\n",
    "    \n",
    "    # ç¡®ä¿æ‰€æœ‰åŒºåŽ¿éƒ½æœ‰æ•°æ®\n",
    "    common_boroughs = set(ev_demand.index) & set(traffic_intensity.index) & set(charging_density.index)\n",
    "    \n",
    "    gap_scores = {}\n",
    "    for borough in common_boroughs:\n",
    "        gap_score = (w1 * ev_demand[borough] + \n",
    "                    w2 * traffic_intensity[borough] - \n",
    "                    w3 * charging_density[borough])\n",
    "        gap_scores[borough] = gap_score\n",
    "    \n",
    "    return pd.Series(gap_scores, name='gap_score').sort_values(ascending=False)\n",
    "\n",
    "# è®¡ç®—Gap Score\n",
    "gap_scores = calculate_gap_score(ev_demand, traffic_intensity, charging_density)\n",
    "\n",
    "print(\"\\nGap Scores by borough (æŽ’åº - é«˜åˆ°ä½Ž):\")\n",
    "for borough, score in gap_scores.items():\n",
    "    print(f\"{borough}: {score:.2f}\")\n",
    "\n",
    "# %%\n",
    "# ===== 4. ç»“æžœå¯è§†åŒ– =====\n",
    "print(\"\\nðŸ“ˆ Creating visualizations...\")\n",
    "\n",
    "# 4.1 Gap Scoreç»„ä»¶å¯¹æ¯”\n",
    "fig, axes = plt.subplots(2, 2, figsize=(15, 10))\n",
    "\n",
    "# EVéœ€æ±‚\n",
    "axes[0,0].bar(ev_demand.index, ev_demand.values, color='lightblue', alpha=0.7)\n",
    "axes[0,0].set_title('EV Demand Proxy by Borough')\n",
    "axes[0,0].set_ylabel('Demand Score')\n",
    "axes[0,0].tick_params(axis='x', rotation=45)\n",
    "\n",
    "# äº¤é€šå¼ºåº¦\n",
    "axes[0,1].bar(traffic_intensity.index, traffic_intensity.values, color='lightgreen', alpha=0.7)\n",
    "axes[0,1].set_title('Traffic Intensity by Borough')\n",
    "axes[0,1].set_ylabel('Traffic Score')\n",
    "axes[0,1].tick_params(axis='x', rotation=45)\n",
    "\n",
    "# å……ç”µå¯†åº¦\n",
    "axes[1,0].bar(charging_density.index, charging_density.values, color='lightcoral', alpha=0.7)\n",
    "axes[1,0].set_title('Current Charging Density by Borough')\n",
    "axes[1,0].set_ylabel('Stations per sq mile')\n",
    "axes[1,0].tick_params(axis='x', rotation=45)\n",
    "\n",
    "# Gap Score\n",
    "colors = ['red' if x > 6 else 'orange' if x > 4 else 'green' for x in gap_scores.values]\n",
    "axes[1,1].bar(gap_scores.index, gap_scores.values, color=colors, alpha=0.7)\n",
    "axes[1,1].set_title('Gap Scores by Borough')\n",
    "axes[1,1].set_ylabel('Gap Score')\n",
    "axes[1,1].tick_params(axis='x', rotation=45)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# %%\n",
    "# 4.2 åˆ›å»ºGap Scoreåœ°å›¾\n",
    "print(\"\\nðŸ—ºï¸  Creating Gap Score map...\")\n",
    "\n",
    "def create_gap_score_map(df_stations, gap_scores):\n",
    "    \"\"\"\n",
    "    åˆ›å»ºæ˜¾ç¤ºGap Scoreçš„äº¤äº’åœ°å›¾\n",
    "    \"\"\"\n",
    "    # åˆå§‹åŒ–åœ°å›¾\n",
    "    m = folium.Map(location=[40.7128, -74.0060], zoom_start=10)\n",
    "    \n",
    "    # åŒºåŽ¿ä¸­å¿ƒç‚¹åæ ‡ (å¤§è‡´)\n",
    "    borough_centers = {\n",
    "        'Manhattan': [40.7831, -73.9712],\n",
    "        'Brooklyn': [40.6782, -73.9442], \n",
    "        'Queens': [40.7282, -73.7949],\n",
    "        'Bronx': [40.8448, -73.8648],\n",
    "        'Staten Island': [40.5795, -74.1502]\n",
    "    }\n",
    "    \n",
    "    # ä¸ºæ¯ä¸ªåŒºåŽ¿æ·»åŠ Gap Scoreæ ‡è®°\n",
    "    for borough, score in gap_scores.items():\n",
    "        if borough in borough_centers:\n",
    "            # æ ¹æ®Gap Scoreç¡®å®šé¢œè‰²\n",
    "            if score > 6:\n",
    "                color = 'red'\n",
    "                priority = 'HIGH'\n",
    "            elif score > 4:\n",
    "                color = 'orange' \n",
    "                priority = 'MEDIUM'\n",
    "            else:\n",
    "                color = 'green'\n",
    "                priority = 'LOW'\n",
    "            \n",
    "            folium.Marker(\n",
    "                location=borough_centers[borough],\n",
    "                popup=f\"<b>{borough}</b><br>\"\n",
    "                      f\"Gap Score: {score:.2f}<br>\"\n",
    "                      f\"Priority: {priority}<br>\"\n",
    "                      f\"EV Demand: {ev_demand.get(borough, 'N/A'):.1f}<br>\"\n",
    "                      f\"Traffic: {traffic_intensity.get(borough, 'N/A'):.1f}<br>\"\n",
    "                      f\"Charging Density: {charging_density.get(borough, 'N/A'):.1f}\",\n",
    "                icon=folium.Icon(color=color, icon='info-sign')\n",
    "            ).add_to(m)\n",
    "    \n",
    "    # æ·»åŠ çŽ°æœ‰å……ç”µç«™\n",
    "    for _, station in df_stations.dropna(subset=['LATITUDE', 'LONGITUDE']).iterrows():\n",
    "        folium.CircleMarker(\n",
    "            location=[station['LATITUDE'], station['LONGITUDE']],\n",
    "            radius=2,\n",
    "            popup=station.get('STATION NAME', 'Unknown'),\n",
    "            color='blue',\n",
    "            fill=True,\n",
    "            fillOpacity=0.3\n",
    "        ).add_to(m)\n",
    "    \n",
    "    # æ·»åŠ å›¾ä¾‹\n",
    "    legend_html = '''\n",
    "    <div style=\"position: fixed; \n",
    "                bottom: 50px; right: 50px; width: 200px; height: 120px; \n",
    "                background-color: white; border:2px solid grey; z-index:9999; \n",
    "                font-size:14px; padding: 10px\">\n",
    "    <b>Gap Score Priority:</b><br>\n",
    "    <i class=\"fa fa-map-marker\" style=\"color:red\"></i> HIGH (>6.0)<br>\n",
    "    <i class=\"fa fa-map-marker\" style=\"color:orange\"></i> MEDIUM (4.0-6.0)<br>\n",
    "    <i class=\"fa fa-map-marker\" style=\"color:green\"></i> LOW (<4.0)<br>\n",
    "    <i class=\"fa fa-circle\" style=\"color:blue\"></i> Existing Stations\n",
    "    </div>\n",
    "    '''\n",
    "    m.get_root().html.add_child(folium.Element(legend_html))\n",
    "    \n",
    "    return m\n",
    "\n",
    "# åˆ›å»ºåœ°å›¾\n",
    "gap_map = create_gap_score_map(df_clean, gap_scores)\n",
    "\n",
    "# ä¿å­˜åœ°å›¾\n",
    "gap_map.save('nyc_gap_score_map.html')\n",
    "print(\"Gap Score map saved as 'nyc_gap_score_map.html'\")\n",
    "\n",
    "# %%\n",
    "# ===== 5. ä¼˜å…ˆçº§æŽ¨è =====\n",
    "print(\"\\nðŸŽ¯ Priority Recommendations:\")\n",
    "print(\"=\" * 50)\n",
    "\n",
    "high_priority = gap_scores[gap_scores > 6].index.tolist()\n",
    "medium_priority = gap_scores[(gap_scores > 4) & (gap_scores <= 6)].index.tolist()\n",
    "low_priority = gap_scores[gap_scores <= 4].index.tolist()\n",
    "\n",
    "print(f\"ðŸ”´ HIGH PRIORITY (Gap Score > 6.0): {high_priority}\")\n",
    "print(f\"ðŸŸ¡ MEDIUM PRIORITY (Gap Score 4.0-6.0): {medium_priority}\")\n",
    "print(f\"ðŸŸ¢ LOW PRIORITY (Gap Score < 4.0): {low_priority}\")\n",
    "\n",
    "print(f\"\\nðŸ“Š Summary Statistics:\")\n",
    "print(f\"Average Gap Score: {gap_scores.mean():.2f}\")\n",
    "print(f\"Standard Deviation: {gap_scores.std():.2f}\")\n",
    "print(f\"Range: {gap_scores.min():.2f} - {gap_scores.max():.2f}\")\n",
    "\n",
    "# %%\n",
    "# ===== 6. ä¸‹ä¸€æ­¥è®¡åˆ’ =====\n",
    "print(f\"\\nðŸ“‹ Next Steps:\")\n",
    "print(\"1. æ”¶é›†æ›´è¯¦ç»†çš„å¤–éƒ¨æ•°æ® (äººå£æ™®æŸ¥ã€äº¤é€šæ•°æ®ç­‰)\")\n",
    "print(\"2. å®žçŽ°ZIP codeçº§åˆ«çš„Gap Scoreè®¡ç®—\") \n",
    "print(\"3. å¼€å‘ç‰¹å¾å·¥ç¨‹ (ç‹¬ç«‹å˜é‡é€‰æ‹©)\")\n",
    "print(\"4. è®­ç»ƒæœºå™¨å­¦ä¹ æ¨¡åž‹é¢„æµ‹Gap Score\")\n",
    "print(\"5. ç”Ÿæˆå…·ä½“çš„æ–°ç«™ç‚¹åæ ‡æŽ¨è\")\n",
    "\n",
    "# %%\n",
    "# ä¿å­˜ç»“æžœç”¨äºŽä¸‹ä¸€ä¸ªnotebook\n",
    "gap_scores.to_csv('gap_scores_by_borough.csv')\n",
    "print(f\"\\nGap scores saved to 'gap_scores_by_borough.csv'\")"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
